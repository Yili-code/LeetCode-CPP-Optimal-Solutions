# vector

## 1. 基本定義 (Basic Definition)
- **資料結構 (Data Structure)**：  
  C++ STL 中的**動態陣列 (Dynamic Array)**，支援連續記憶體存儲、隨機存取及動態擴容。  
  
- **元素特性 (Element Properties)**：  
  - 連續記憶體分配，元素間緊密排列。  
  - 支援動態增減元素，但容量增長通常是倍增擴容。  
  - 尾端操作效率極高，頭部或中間插入刪除需搬移大量元素。

---

## 2. 底層實現原理 (Underlying Implementation)
1. **連續記憶體配置**  
   - 元素緊鄰排列，支援快速索引 (O(1))。  
   - 訪問位址計算：`起始地址 + (索引 × 元素大小)`。

2. **動態擴容 (Dynamic Resizing)**  
   - 當容量不足時，vector 會分配更大連續空間，並將舊元素複製至新空間。  
   - 擴容通常以 2 倍成長，但具體實作由 STL 決定。

3. **迭代器失效 (Iterator Invalidation)**  
   - 擴容或中間插入刪除會導致舊指標、迭代器、引用失效。

4. **空間管理**  
   - **size**：當前元素個數  
   - **capacity**：當前已分配的空間容量  
   - **shrink_to_fit()**：嘗試釋放多餘容量，但不保證立即生效。

---

## 3. 常見操作與時間複雜度 (Common Operations & Complexity)

| 操作 (Operation)    | 語法 (Syntax)       | 平均時間 (Average) | 最壞時間 (Worst) | 備註 |
|---------------------|---------------------|--------------------|------------------|------|
| 存取元素            | `v[i]` / `v.at(i)`  | O(1)               | O(1)             | `at()` 有邊界檢查 |
| 尾端插入            | `v.push_back(val)`  | 均攤 O(1)          | O(n)（擴容時）    | |
| 尾端刪除            | `v.pop_back()`      | O(1)               | O(1)             | |
| 任意位置插入        | `v.insert(pos,val)` | O(n)               | O(n)             | 需搬移後續元素 |
| 任意位置刪除        | `v.erase(pos)`      | O(n)               | O(n)             | |
| 調整大小            | `v.resize(n)`       | O(n)（初始化新元素）| O(n)             | |
| 擴容預留            | `v.reserve(n)`      | O(1)               | O(n)（重新配置時）| 減少多次擴容 |
| 釋放多餘容量        | `v.shrink_to_fit()` | 不保證 O(1)        | -                | |

---

## 4. 與相近資料結構比較 (Comparison with Similar Data Structures)

| 資料結構 | 連續記憶體 | 動態大小 | 頭尾插入效率 | 隨機存取 | 適用場景 |
|----------|------------|----------|--------------|----------|----------|
| **vector** | ✅ 是 | ✅ 是 | 尾端 O(1)，頭部 O(n) | O(1) | 頻繁尾端操作、隨機存取 |
| **deque**  | ❌ 分段 | ✅ 是 | 頭尾 O(1) | O(1) | 頭尾操作頻繁 |
| **list**   | ❌ 否 | ✅ 是 | 頭尾 O(1)，中間 O(1) | O(n) | 頻繁中間插入刪除 |
| **array (C-style)** | ✅ 是 | ❌ 否 | N/A | O(1) | 固定大小，高速存取 |

---

## 5. 使用情境 (Usage Scenarios)
1. **需要動態增減且多為尾端操作**  
   - 例：合併數據、緩衝區、儲存動態輸入。   

2. **需要快速隨機存取**  
   - 例：動態查詢、演算法暫存數據。  

3. **不頻繁插入刪除中間元素**  
   - 若需頻繁中間插入，應使用 list 或 deque。

---

## 6. 較少人思考的點 (Less-Discussed Points)
1. **頻繁擴容的成本**  
   - 每次擴容需新建大容量空間並複製所有舊元素，成本高。可用 `reserve()` 預先分配。  

2. **記憶體碎片化問題**  
   - 需要大塊連續空間，在極大數據下可能配置失敗。  

3. **shrink_to_fit() 不一定釋放空間**  
   - 僅建議縮減容量，具體由實作決定。  

4. **迭代器失效**  
   - 擴容、插入、刪除會使舊迭代器失效，需重新獲取。  

5. **拷貝與移動語意**  
   - C++11 後可使用移動構造減少不必要拷貝，特別是 push_back 大型物件時。

---

## 7. LeetCode 經典題目 (Classic Problems)

| 題號 | 題名                       | 重點                 |
|------|----------------------------|----------------------|
| 88   | Merge Sorted Array          | 原地合併已排序陣列   |
| 27   | Remove Element              | 原地刪除指定元素     |
| 283  | Move Zeroes                 | 就地移動非零元素     |
| 31   | Next Permutation            | 原地修改序列排列     |
| 56   | Merge Intervals             | 需要排序與隨機訪問   |
| 118  | Pascal's Triangle           | 動態擴展儲存結構     |

---
